# GDB简介
- 什么是 GDB ?
    - GUN项目中的调试器(gun debuger)
    - <font color=red>能够跟踪程序的执行</font>, 也能够<font color=red>恢复程序崩溃前的状态</font>
- 为什么需要 GDB ?
    - 软件不是一次性开发完成的(是软件就有bug, 是程序就有问题)
    - 调试是软件开发过程中不可或缺的技术(调试工具很重要)

- GDB 的常规应用
    - 自定义程序的启动方式 (指定影响程序运行的参数)
    - 设置条件断点 (在条件满足时暂停程序的执行)
    - 回溯检查导致程序异常结束的原因 (Core Dump)
        > 比 addr2line 更方便
    - 动态改变程序执行流 (定位问题的辅助方式)
        > 跳过某一行语句的执行

    > GDB 与前面讲的GUN工具集的区别:
    > GUN工具集 : 静态分析工具, 目标是程序文件
    > GDB : 动态分析工具, 目标是进程

# GDB 的启动方式
- 直接启动
    - gdb
    - gdb <font color=blue>test.out</font>
    - gdb <font color=blue>test.out</font> core
 - 动态链接
     - gdb <font color=blue>test.out</font> pid

# GDB 应用示例
- 应用示例一
    <pre>
    - delphi@delphi-vm:~$ <font color=blue>gdb</font>      // 启动
    - (gdb) <font color=blue>file</font> <font color=purple>test.out</font>          // 载入目标程序
    - (gdb) <font color=blue>set args</font> <font color=purple>arg1 arg2</font>     // 设置命令行参数
    - (gdb) <font color=blue>run</font>                    // 执行目标程序
    </pre>
    ![](vx_images/_v_images_11/1.png)

- 应用示例二 - 跟踪某个进程的执行
    <pre>
    - delphi@delphi-vm:~$ <font color=blue>gdb</font>      // 启动
    - (gdb) <font color=blue>attach</font> <font color=purple>pid</font>             // 链接到目标进程, 链接成功后
                                   // 目标进程将停止执行
    - (gdb) <font color=blue>continue</font>               // 恢复执行
    </pre>
    ![](vx_images/_v_images_11/2.png)

# [<u>实验</u>](vx_attachments/code/11_GDB_Debugging_weapon_1)
编译运行, 出现段错误

<pre style=" background-color:#fff">
$ gcc <font color=red>-g</font> *.c
$ ./a.out
main() : begin...
argv[0] = ./a.out
test_1() : 0x40063a
test_2() : 0x400655
test_3() : 0x400670
...
test_2() : 0x400655
test_3() : 0x400670
test_1() : 0x40063a
g_pointer = (nil)
Segmentation fault (core dumped)
</pre>

## core
让程序崩溃时产生core文件

<pre style=" background-color:#fff">
$ ulimit -c unlimited
</pre>

再次运行调试

<pre style=" background-color:#fff">
$ ./a.out
main() : begin...
argv[0] = ./a.out
test_1() : 0x40063a
test_2() : 0x400655
test_3() : 0x400670
...
test_2() : 0x400655
test_3() : 0x400670
test_1() : 0x40063a
g_pointer = (nil)
Segmentation fault (core dumped)
$ ls core
core
</pre>

> 不能在中文路径下生成 core 文件
> 将 `ulimit -c unlimited` 放置于 `/etc/profile` 可不用每次手动敲命令

<pre style=" background-color:#fff">
$ gdb a.out core
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
Copyright (C) 2016 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from a.out...done.
[New LWP 2547]
Core was generated by `./a.out'.
Program terminated with signal SIGSEGV, Segmentation fault.
<font color=red>#0  0x0000000000400631 in func () at func.c:5</font>
5           *g_pointer = 98;
(gdb)  quit
$
</pre>

> 运行结果与addr2line分析结果是一致的, addr2line其实并不是用于分析地址问题的, 它只不过是做翻译的, 将具体的地址翻译到对应的代码行, 而GDB才是真真正正用于动态定位问题的

## file
- file : gdb内部的指令, 指明gdb关注文件对应的进程

<pre style=" background-color:#fff">
$ gdb
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
Copyright (C) 2016 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word".
(gdb) <font color=blue>file a.out</font>
Reading symbols from a.out...done.
(gdb) <font color=blue>run</font>
Starting program: /home/book/4_computer_foundation/1_computer_fundamental/11_GDB_Debugging_weapon_1/code/a.out
main() : begin...
argv[0] = /home/book/4_computer_foundation/1_computer_fundamental/11_GDB_Debugging_weapon_1/code/a.out
test_1() : 0x40063a
test_2() : 0x400655
test_3() : 0x400670
...
test_2() : 0x400655
test_3() : 0x400670
test_1() : 0x40063a
g_pointer = (nil)

Program received signal SIGSEGV, Segmentation fault.
<font color=red>0x0000000000400631 in func () at func.c:5</font>
5           *g_pointer = 98;
(gdb) quit
A debugging session is active.

        Inferior 1 [process 2583] will be killed.

Quit anyway? (y or n) y
$
</pre>

## set args
- set args xxx : 设置命令行和参数
    Ctrl+c : 程序暂停执行
    continue : 程序继续运行

<pre style=" background-color:#fff">
$ gdb a.out
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
Copyright (C) 2016 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from a.out...done.
(gdb) <font color=blue>set args hello</font>
(gdb) <font color=blue>run</font>
Starting program: /home/book/4_computer_foundation/1_computer_fundamental/11_GDB_Debugging_weapon_1/code/a.out hello
main() : begin...
argv[0] = /home/book/4_computer_foundation/1_computer_fundamental/11_GDB_Debugging_weapon_1/code/a.out
<font color=red>argv[1] = hello</font>
test_1() : 0x40063a
test_2() : 0x400655
test_3() : 0x400670
test_1() : 0x40063a
<font color=blue>^C</font>
Program received signal SIGINT, Interrupt.
0x00007ffff7ad92f0 in __nanosleep_nocancel () at ../sysdeps/unix/syscall-template.S:84
84      ../sysdeps/unix/syscall-template.S: No such file or directory.
(gdb) <font color=blue>continue</font>
Continuing.
test_2() : 0x400655
test_3() : 0x400670
...
test_3() : 0x400670
test_1() : 0x40063a
g_pointer = (nil)

Program received signal SIGSEGV, Segmentation fault.
0x0000000000400631 in func () at func.c:5
5           *g_pointer = 98;
(gdb) q
A debugging session is active.

        Inferior 1 [process 2614] will be killed.

Quit anyway? (y or n) y
$
</pre>

## GDB动态链接到已经运行的进程 - attach
- 开两个终端窗口
    - 一个执行程序
        ./a.out hello
    - 另一个GDB调试
         ps aux 查进程对应的pid
         sudo gdb     // 动态链接进程,需要管理员权限)
         attach `<pid>`    // 此时进程停止执行, 相当于发送了个 Ctrl+C 信号
         continue // 继续运行
         运行到最后gdb显示进程的段错误及位置


# GDB 断点调试
- 使用GDB进行断点调试
    - 断点类型
        - 软件断点 : 由<font color=red>非法指令异常</font>实现 (软件实现)(前面提过:通过中断来实现的)
        - 硬件断点 : 由<font color=blue>硬件特性</font>实现 (数量有限)
        - 数据断点 : 由<font color=blue>硬件特性</font>实现 (数量有限)
        > - 为什么要区分软件断点和硬件断点?
        > 答 : 软件断点通常能够有效地用于运行于内存中的程序, 如果说程序时是被加载进内存中执行的,软件断点调试就是有效的; 对于在flash中的程序执行,就必须依赖于硬件断点.
        > - 数据断点作用?
        > 答 : 数据断点往往用来监视一段内存, 如果这段内存被访问了(被读或被写),程序的执行都会立即停下来.

- 软件断点的相关操作
    - 通过函数名设置断点 (中括号为条件断点)
        - <font color=blue>break</font> func_name [ if var = value ]
        - <font color=purple>tbreak</font> func_name [ if var = value ]
    - 通过文件名行号设置断点 (中括号为条件断点)
        - <font color=blue>break</font> file_name:line_num [ if var = value ]
        - <font color=purple>tbreak</font> file_name:line_num [ if var = value ]
    > - break 和 tbreak 的差异?
    > 答 : 断点的有效次数, break设置的断点总是有效的; tbreak是设置一次有效断点, 只要程序执行到对应的断点处, 程序就会停止, 停止后这个断点就不会有效了

    |    操作     |        命令         |
    | ----------- | ------------------- |
    | 断点查看     | info breakpoints    |
    | 断点删除     | delete 1 2 n        |
    |             | delete breakpoints  |
    | 断点状态改变 | enable 1 2 n        |
    |             | enable breakpoints  |
    |             | disable 1 2 n       |
    |             | disable breakpoints |

- 调试时的常用操作

    |       操作       |        命令        |
    | ---------------- | ------------------ |
    | 变量查看          | print name         |
    | 变量设置          | set var name=value |
    | 执行下一行代码     | next               |
    | 连续执行n行代码    | next n             |
    | 执行进入函数      | step               |
    | 强制当前函数返回   | return [value]     |
    | 运行至当前函数返回 | finish             |
    | 执行至目标行      | until line         |
    | 跳转执行 (强制)   | jump line          |

- 硬件断点及其应用
    - <font color=purple>当代码位于只读存储器(flash)时</font>, <font color=red>只能通过硬件断点调试</font>
    - 硬件断点需要<font color=blue>硬件支持</font>, 数量有限
    - GDB 中通过 <font color=blue>hbreak</font> 命令支持硬件断点
    - <font color=blue>hbreak</font> 与 <font color=red>break</font> 使用方式完全一致

# [<u>实验</u>](vx_attachments/code/11_GDB_Debugging_weapon_1)
<pre style=" background-color:#fff">
$ gcc -g *.c
</pre>
## 第一次调试

<pre style=" background-color:#fff">
$ gdb a.out
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
Copyright (C) 2016 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from a.out...done.
(gdb) <font color=blue>set args hello</font>
(gdb) <font color=blue>start</font>
Temporary breakpoint 1 at 0x40069a: file test.c, line 21.
Starting program: /home/.../11_GDB_Debugging_weapon_1/code/a.out hello

Temporary breakpoint 1, main (argc=2, argv=0x7fffffffe358) at test.c:21
21      {
(gdb) <font color=blue>break test.c:33</font>
Breakpoint 2 at 0x40071b: file test.c, line 33.
(gdb) info breakpoints
Num     Type           Disp Enb Address            What
2       breakpoint     keep y   0x000000000040071b in main at test.c:33
(gdb) <font color=blue>continue</font>
Continuing.
main() : begin...
argv[0] = /home/book/.../11_GDB_Debugging_weapon_1/code/a.out
argv[1] = hello

Breakpoint 2, main (argc=2, argv=0x7fffffffe358) at test.c:33
33              fa[i%3]();
(gdb) <font color=blue>next</font>
test_1() : 0x40063a
34              sleep(argc > 1);
(gdb) <font color=blue>next</font>
32          for(i = 0; i < 100; i++) {
(gdb) <font color=blue>next</font>

Breakpoint 2, main (argc=2, argv=0x7fffffffe358) at test.c:33
33              fa[i%3]();
(gdb) <font color=blue>print i</font>
$1 = 1
(gdb) <font color=blue>set var i=100</font>    // 设置变量值,快速跳出循环
(gdb) <font color=blue>print i</font>
$2 = 100
(gdb) <font color=blue>print i</font>
$3 = 100
(gdb) <font color=blue>next</font>
test_2() : 0x400655
34              sleep(argc > 1);
(gdb) <font color=blue>next</font>
32          for(i = 0; i < 100; i++) {
(gdb) <font color=blue>next</font>
37          printf("g_pointer = %p\n", g_pointer);
(gdb) <font color=blue>tbreak test.c:38</font>        // 设置临时断点
Temporary breakpoint 3 at 0x40077b: file test.c, line 38.
(gdb) <font color=blue>info breakpoints</font>
Num     Type           Disp Enb Address            What
2       breakpoint     keep y   0x000000000040071b in main at test.c:33
        breakpoint already hit 2 times
3       breakpoint     del  y   0x000000000040077b in main at test.c:38
(gdb) <font color=blue>jump 40</font>    // 不运行func这个函数,跳转到40行
Continuing at 0x400785.
main() : end...
[Inferior 1 (process 3137) exited normally]    // 程序正常结束
</pre>
## 第二次调试
调用func函数, 但是不执行func函数体

<pre style=" background-color:#fff">
$ gdb a.out
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
Copyright (C) 2016 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from a.out...done.
(gdb) <font color=blue>start</font>
Temporary breakpoint 1 at 0x40069a: file test.c, line 21.
Starting program: /home/.../11_GDB_Debugging_weapon_1/code/a.out

Temporary breakpoint 1, main (argc=1, argv=0x7fffffffe368) at test.c:21
21      {
(gdb) <font color=blue>tbreak func</font>    //通过函数名来打断点
Temporary breakpoint 2 at 0x40062a: file func.c, line 5.
(gdb) <font color=blue>info breakpoints</font>
Num     Type           Disp Enb Address            What
2       breakpoint     del  y   0x000000000040062a in func at func.c:5
(gdb) <font color=blue>continue</font>
Continuing.
main() : begin...
argv[0] = /home/.../11_GDB_Debugging_weapon_1/code/a.out
test_1() : 0x40063a
test_2() : 0x400655
test_3() : 0x400670
...
test_2() : 0x400655
test_3() : 0x400670
test_1() : 0x40063a
g_pointer = (nil)

Temporary breakpoint 2, func () at func.c:5
5           *g_pointer = 98;
(gdb) <font color=blue>return</font>    // 强制func返回
Make func return now? (y or n) y
#0  main (argc=1, argv=0x7fffffffe368) at test.c:40
40          printf("main() : end...\n");
(gdb) <font color=blue>continue</font>
Continuing.
main() : end...
[Inferior 1 (process 3170) exited normally]    // 程序正常结束
</pre>
## 第三次调试
验证解决方案

<pre style=" background-color:#fff">
$ gdb a.out
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
Copyright (C) 2016 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from a.out...done.
(gdb) <font color=blue>start</font>
Temporary breakpoint 1 at 0x40069a: file test.c, line 21.
Starting program: /home/.../11_GDB_Debugging_weapon_1/code/a.out

Temporary breakpoint 1, main (argc=1, argv=0x7fffffffe368) at test.c:21
21      {
(gdb) <font color=blue>show can-use-hw-watchpoints</font>    // 查看当前gdb支持多少个硬件断点 (1个)
Debugger's willingness to use watchpoint hardware is 1.
(gdb) <font color=blue>hbreak func</font>    // func函数处打硬件断点
Hardware assisted breakpoint 2 at 0x40062a: file func.c, line 5.
(gdb) <font color=blue>info breakpoints</font>
Num     Type           Disp Enb Address            What
2       hw breakpoint  keep y   0x000000000040062a in func at func.c:5
(gdb) <font color=blue>continue</font>
Continuing.
main() : begin...
argv[0] = /home/.../11_GDB_Debugging_weapon_1/code/a.out
test_1() : 0x40063a
test_2() : 0x400655
test_3() : 0x400670
...
test_2() : 0x400655
test_3() : 0x400670
test_1() : 0x40063a
g_pointer = (nil)

Breakpoint 2, func () at func.c:5
5           *g_pointer = 98;
(gdb) <font color=blue>print g_pointer</font>
$1 = (int *) 0x0
(gdb) <font color=blue>set var g_pointer=(int *)malloc(sizeof(int))</font>
(gdb) <font color=blue>print g_pointer</font>
$2 = (int *) 0x602420
(gdb) <font color=blue>continue</font>
Continuing.
main() : end...
[Inferior 1 (process 3182) exited normally]    // 程序正常结束
</pre>
> 1. start命令用来启动可执行程序, 和run命令的区别是: run是单纯的启动可执行程序, start在启动可执行程序之后, 立即暂停
> 2. $1 和 $2 代表第一次打印变量和第二次打印变量
> 3. 实测 : 第三次调试中, 用 hbreak(硬件断点) 和 break(软件断点) 效果是一样的

# 小结
- GDB 是 <font color=blue>GUN 项目中的调试器</font>, 能够跟踪或改变程序的执行
- GDB 能够根据 Core Dump <font color=green>回溯检查导致程序异常结束的原因</font>
- GDB 同时支持<font color=purple>软件断点</font>, <font color=purple>硬件断点</font>和<font color=purple>数据断点</font>
- GDB 是嵌入式开发中<font color=red>必须掌握</font>的重要工具
