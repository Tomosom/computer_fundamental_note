# 函数调用时发生了什么?
- ABI 定义了函数调用时
    - 栈帧的内存布局
    - 栈帧的形成方式
    - 栈帧的销毁方式

    ![](_v_images_15/1.png)
    > esp (栈顶指针寄存器), 指向当前栈存储区的顶部

 - ebp 是函数调用以及函数返回的核心寄存器
    - <font color=#00d>ebp 为当前栈帧的基准</font> (存储上一个栈帧的 ebp 值)
    - 通过 ebp 能够获取<font color=#d00>返回值地址, 参数, 局部变量</font>, 等

    ![](_v_images_15/2.png)
    > 右边箭头表示上面是高地址,下面是低地址
    > caller : 函数调用者栈帧的局部; callee : 被调函数栈帧的局部
    > ebp存储方式类似链表, 任意一个节点都保存了下一个节点的地址, 任意一个栈帧都保存了上一个栈帧的基准地址

- Linux 中栈帧布局 (与上面的表格类似)

    ![](_v_images_15/3.png)
    > 系统的ABI规范规定的这样的存储方式

- 函数调用发生时的细节操作
    - 调用者通过 <font color=#00d>call</font> 指令调用函数, <font color=#00d>将返回地址压入栈中</font>
    - 函数所需要的<font color=#d00>栈空间大小由编译器确定</font>, 表现为字面常量(汇编代码的)
        > 每一个函数对应的栈帧的大小是不定的, 编译器在编译的时候确定了当前函数所需要的栈空间的大小
    - 函数结束时, <font color=#d0d>leave质量恢复上一个栈帧的 esp 和 ebp</font>
    - 函数返回时, <font color=#00d>ret 指令将返回地址恢复到 eip(PC) 寄存器</font>

    ![](_v_images_15/4.png)
    > - `move ebp, esp` : 将ebp赋给esp
    > - `pop ebp` : 将上一个栈帧的ebp pop 给 ebp
    > - eip : 指令寄存器 (将 return address pop 给 eip), 在返回的地方继续执行程序

- 函数调用时的"前言"和"后续" (被高级语言隐藏的两个细节的行为)

    |                  前言                   |              后续               |
    | --------------------------------------- | ------------------------------- |
    | push ebp                                | <font color=gray>pop ...</font> |
    | move esp, ebp                           | <font color=gray>pop ebx</font> |
    | sub <font color=red>$(SIZE)</font>, esp | <font color=gray>pop esi</font> |
    | <font color=gray>push edi</font>        | <font color=gray>pop edi</font> |
    | <font color=gray>push esi</font>        | leave                           |
    | <font color=gray>push ebx</font>        | ret                             |
    | <font color=gray>push ...</font>        |                                 |
    > - 前言和后续的中间, 就是我们用高级语言编写的代码逻辑
    > - 前沿和后续对每个函数来说基本上是一致的, 因此编译器就将这些一致的行为隐藏了
    > - `sub $(SIZE), esp` : 将esp的值做减法, 即esp的值往低地址处移动了, 接下来就是往当前栈帧中写内容了
    > - 前言所做的事情就是为了形成栈帧的, 先确定当前栈帧的基准地址,然后确定当前栈帧的大小
    > - 后续行为, leave就是摧毁当前的栈帧, ret就是真正的函数返回
    > - 灰色部分 : 对每个函数来说,都会使用一些寄存器, 寄存器的数目是有限的, 因此对于一个函数而言, 使用寄存器之前, 应该将寄存器原先的值保存(push)下来(保存在当前栈帧中), 栈帧销毁时,恢复(pop)这些寄存器的值
    > - 这里对于通用寄存器 edi, esi, ebx 的 push(pop)操作并不是压栈(出栈)操作; 而是表示将对应寄存器的值存入栈帧中(从栈帧中取出), 存取的顺序正好相反.

- GDB 小贴士 : info frame 命令输出的阅读

    ![](_v_images_15/5.png)
    > 红框中内容 : 参数列表和局变量的列表都可以通过红框中的地址或得到, 这个地址就是ebp(栈帧基准地址)

# [<u>编程实验 - 函数栈帧结构初探</u>](code/15_缔造程序兼容的合约-下)


# 调用约定
- 问题
    - 函数调用时,参数如何入栈?
    - 函数返回时, 返回值在哪里?

- C语言默认使用的调用约定 (`__cdecl__`)
    - 调用函数时, 参数从右向左入栈
    - 函数返回时, 函数的调用者负责将参数弹出栈
    - 函数返回值保存在 eax 寄存器中

- 其他各种调用约定

    ![](_v_images_15/6.png)

- 一些注意事项
    - 只有使用了 `__cdecl__` 的函数支持可变参数定义
    - 当类的成员函数为可变参数时, 调用约定自动变为 `__cdecl__`
    - 嗲用约定定义了函数被编译后对应的最终符号名

# 实验 - 函数调用约定


# q
- 问题
    - 当返回值类型为结构体时, 如何将值返回到调用函数中 ?

- 结构体类型的返回值
    - 函数调用时, 接收返回值的变量地址需要入栈
    - 被调函数直接通过变量地址拷贝返回值
    - 函数返回值用于初始化与赋值对应的过程不同

- 函数返回值初始化变量

    ![](_v_images_15/7.png)

- 函数返回值给变量赋值

    ![](_v_images_15/8.png)

# 实验 - 结构体函数返回值


# 小结
- 栈帧是函数调用时形成的链式内存结构
- ebp 是构成栈帧的核心基准寄存器
- 调用约定决定了函数调用时的细节行为
- 基础数据类型的返回值通过 eax 传递
- 结构体类型的返回值通过内存拷贝完成
