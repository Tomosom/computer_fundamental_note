- ABI 定义了函数调用时
    - 栈帧的内存布局
    - 栈帧的形成方式
    - 栈帧的销毁方式

    ![](_v_images_15/1.png)

- ebp 是函数调用以及函数返回的核心寄存器
    - ebp 为当前栈帧的基准 (存储上一个栈帧的 ebp 值)
    - 通过 ebp 能够获取返回值地址, 参数, 局部变量, 等

    ![](_v_images_15/2.png)

- Linux 中栈帧布局

    ![](_v_images_15/3.png)

- 函数调用发生时的细节操作
    - 调用者通过 call 指令调用函数, 将返回地址压入栈中
    - 函数所需要的栈空间大小由编译器确定, 表现为字面常量
    - 函数结束时, leave质量恢复上一个栈帧的 esp 和 ebp
    - 函数返回时, ret 指令将返回地址恢复到 eip(PC) 寄存器

    ![](_v_images_15/4.png)

- 函数调用时的"前言"和"后续"

    |                  前言                   |  后续   |
    | --------------------------------------- | ------- |
    | push ebp                                | pop ... |
    | move esp, ebp                           | pop ebx |
    | sub <font color=red>$(SIZE)</font>, esp | pop esi |
    | push edi                                | pop edi |
    | push esi                                | leave   |
    | push ebx                                | ret     |
    | push ...                                |         |

- GDB 小贴士 : info frame 命令输出的阅读

    ![](_v_images_15/5.png)

# 编程实验 - 函数栈帧结构初探

# 调用约定
- 问题
    - 函数调用时,参数如何入栈?
    - 函数返回时, 返回值在哪里?

- C语言默认使用的调用约定 (`__cdecl__`)
    - 调用函数时, 参数从右向左入栈
    - 函数返回时, 函数的调用者负责将参数弹出栈
    - 函数返回值保存在 eax 寄存器中

- 其他各种调用约定

    ![](_v_images_15/6.png)

- 一些注意事项
    - 只有使用了 `__cdecl__` 的函数支持可变参数定义
    - 当类的成员函数为可变参数时, 调用约定自动变为 `__cdecl__`
    - 嗲用约定定义了函数被编译后对应的最终符号名

# 实验 - 函数调用约定


# q
- 问题
    - 当返回值类型为结构体时, 如何将值返回到调用函数中 ?

- 结构体类型的返回值
    - 函数调用时, 接收返回值的变量地址需要入栈
    - 被调函数直接通过变量地址拷贝返回值
    - 函数返回值用于初始化与赋值对应的过程不同

- 函数返回值初始化变量

    ![](_v_images_15/7.png)

- 函数返回值给变量赋值

    ![](_v_images_15/8.png)

# 实验 - 结构体函数返回值


# 小结
- 栈帧是函数调用时形成的链式内存结构
- ebp 是构成栈帧的核心基准寄存器
- 调用约定决定了函数调用时的细节行为
- 基础数据类型的返回值通过 eax 传递
- 结构体类型的返回值通过内存拷贝完成
