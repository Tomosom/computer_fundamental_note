# 缔造程序兼容的合约
- 什么是 ABI (Aplication Binary Interface) ?
    - 应用程序二进制接口
        - 数据类型的大小, 数据对齐方式
        - 函数调用发生时的调用约定
        - 系统调用的编号, 以及进行系统调用的方式
        - 目标文件的二进制格式, 程序库格式, 等等

- 什么是EABI (Embedded Aplication Binary Interface) ?
    - 嵌入式应用程序二进制接口
        - 针对嵌入式平台的ABI规范
            - 可链接目标代码以及可执行文件格式的二进制规范
            - 编译链接工具的基础规范, 函数调用规范, 调试格式规范, 等
            - EABI 与 ABI 的主要区别是应用程序代码中允许使用特权指令

- ABI
    - 广义上 ABI 的概念
        - 泛指应用程序在二进制层面应该遵循的规范
    - 狭义上 ABI 的概念
        - 特指
            - 某个具体硬件平台的 ABI 规范文档
            - 某个具体操作系统平台的 ABI 规范文档
            - 某个具体虚拟机平台的 ABI 规范文档

- ABI 规范示例
    - 为什么下面的代码能够以0作为退出码结束程序运行?

    ```c
    asm volatile (
        "movl $1, %eax\n"    // #1 → sys_exit
        "movl $0, %ebx\n"    // exit code
        "int $0x80    \n");  // call sys_exit(0)
    ```

- 问题 : ABI 和 API 有什么不同 ?
    - ABI 和 API 是不同层面的规范
        - ABI 是二进制层面的规范
        - API 是源代码层面的规范
    - ABI 和 API 没有直接联系
        - 遵循相同 ABI 的系统, 所提供的 API 可能不同
        - 所提供 API 相同的系统, 遵循的 ABI 可能不同

# 实验 - ABI 实例分析 跨平台程序原理


# ABI 定义了基础数据类型的大小
- ABI 定义了基础数据类型的大小

    |               |         基础数据类型         | 大小 |
    | ------------- | --------------------------- | --- |
    | Byte / UByte  | signed / unsigned char      | 1    |
    | Short /UShort | signed / unsigned short     | 2    |
    | Int / UInt    | signed / unsigned int       | 4    |
    | Long / ULong  | signed / unsigned long long | 8    |
    | Float         | float                       | 4    |
    | Double        | double                      | 8    |
    | Pointer       | void *                      | 4    |
    > x86平台 ABI 规范中的基础类型

- ABI vs 移植性
    ![](_v_images_14/1.png)

- ABI 定义了结构体 / 联合体的字节对齐方式
    ![](_v_images_14/2.png)

# 实验 - 位域的不同存储方式


# ABI 硬件寄存器的使用方式
- ABI 定义了硬件寄存器的使用方式
    - 寄存器是处理器用来数据和运行程序的重要载体
    - 一些寄存器在处理器设计时就规定好了功能
        - EIP (指令寄存器), 指向处理器下一条要执行的指令
        - ESP (栈顶指针寄存器), 指向当前栈存储区的顶部
        - EBP (栈帧基址寄存器), 指向函数栈帧的重要位置

- x86 寄存器的ABI规范示例

    | 寄存器 |          功能定义          |
    | ----- | ------------------------- |
    | EAX   | 用于存放函数的返回值        |
    | EDX   | 除法运算时需要使用这个寄存器 |
    | ECX   | 计数器寄存器               |
    | EBX   | 局部变量寄存器             |
    | ESI   | 局部变量寄存器             |
    | EDI   | 局部变量寄存器             |

- PowerPC 寄存器的 ABI 规范示例

    |  寄存器   | 类型 |                                功能定义                                 |
    | --------- | --- | ---------------------------------------------------------------------- |
    | R0        | 通用 | used to hold the old link register when building the stack frame       |
    | R1        | 专用 | stack pointer                                                          |
    | R2        | 专用 | table of contents pointer                                              |
    | R3        | 通用 | used as the return value of a function, and also the first argument in                                                      |
    | R4 - R10  | 通用 | used to send in arguments 2 through 8 into a function                  |
    | R11 - R12 | 通用 |                                                                        |
    | CR        | 专用 | condition register                                                     |

- 函数的调用约定
    - 当函数调用发生时
        - 参数会传递给被调用的函数
        - 而返回值会被返回给函数调用者
    - 调用约定描述参数如何传递到栈中以及栈的维护方式
        - 参数传递顺序 (如 : 从右向左进行参数的入栈)
        - 调用栈清理 (如 : 被调用函数负责清理栈)

- 用法
    - 调用约定是 ABI 规范的一部分
    - 调用约定通常用于库调用和库开发的时候
        - 从右到左依次入栈 : `__stdcall, __cdecl, __thiscall`
        - 从左到右依次入栈 : `__pascal, __fastcall`
    ![](_v_images_14/3.png)

# 实验 - ABI 实例分析 VC++ vs C++ Builder


# 小结
- 广义上的 ABI 指应用程序在二进制层面需要遵守的约定
- 狭义上的 ABI 指某一个具体硬件或者操作系统的规范文档
    - ABI 定义了基础数据类型的大小
    - ABI 定义了结构体 / 联合体的字节对齐方式
    - ABI 定义了硬件寄存器的使用方式
    - ABI 定义了函数调用时需要遵守的调用约定

