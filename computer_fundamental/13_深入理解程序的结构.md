# 程序的结构
- 程序由不同的段构成 (最重要的两个段 : 代码段, 数据段)
    - 程序的<font color=blue>静态特征</font>就是指令和数据
    - 程序的<font color=red>动态特征</font>就是执行指令处理数据

- 源程代码到可执行程序文件的对应关系
    `[ File Header ]` : 
    `[ .text ]` : 
    `[ .data & .bss ]` : 
    ![](_v_images_13/1.png)
    > 1. 初始化的, 没初始化的

- 代码段 (.text)
    - 源代码中的可执行语句编译后进入代码段
    - 代码段在有内存管理单元的系统中具有只读属性
    - 代码段的大小在变异结束后就已经固定 (不能动态改变)
    - 代码段中可以包含常量数据 (如 : 常量字符串)

- 数据段 (.data, .bss, .rodata)
    - 数据段用于存放源代码中具有全局生命期的变量
        - .bss
            - 存储未初始化(初始化为0)的变量
        - .data
            - 存储具有非0初始值的变量
        - .rodata
            - 存储const关键字修饰的变量

- 问题
    - 同是全局变量和静态局部变量, 为什么初始化的和未初始化的保存在不同段中?

- 深入理解 .data 和 .bss
    - 程序加载后
        - .bss 段中的所有内存单元被初始化为0
        - 将程序文件中 .data 段相关的初始值写入对应内存单元

    > .bss 段中的变量不用在程序文件中保存初始值, 从而减小可执行程序文件的体积, 并且提高程序的加载效率.

# 实验 - 关键段的分析

# 程序中的栈
- 程序中的栈 (Stack)
    - 程序中栈的本质是一片连续的内存空间
    - SP寄存器作为栈顶 "指针" 实现入栈操作和出栈操作
    ![](_v_images_13/2.png)
- 栈的深入理解
    - 中断发生时, 栈用于保存寄存器的值
    - 函数调用时, 栈用于保存函数的活动记录 (栈帧信息)
    - 并发编程时, 每一个线程拥有自己独立的栈

- 程序中的堆 (Heap)
    - 堆是一片 "闲置" 的内存空间, 用于提供动态内存分配
    - 堆空间的分配需要函数支持 (malloc)
    - 堆空间在使用结束后需要归还 (free)

- 内存映射段 (Memory Mapping Segment)
    - 内核将硬盘文件的内容直接映射到内存映射段(mmap)
    - 动态链接库在可执行程序加载时映射到内存映射段
    - 程序执行时能够创建匿名映射区存放程序数据

- 内存映射文件原理简介
    - 将硬盘上的文件数据逻辑映射到内存中 (零耗时)
    - 通过缺页中断进行文件数据的实际载入 (一次数据拷贝)
    - 映射后的内存的读写就是对文件数据的读写
    ![](_v_images_13/3.png)

# 实验 - 内存映射文件的原理


# 小结
![](_v_images_13/4.png)